{"ast":null,"code":"var debug = require('debug')('waveheader');\n/*\n * WaveHeader\n *\n * writes a pcm wave header to a buffer + returns it\n *\n * taken form\n * from github.com/tooTallNate/node-wav\n * lib/writer.js\n *\n * the only reason for this module to exist is that i couldn't\n * understand how to use the one above, so I made my own.\n * You propably wanna use that one\n */\n\n\nmodule.exports = function generateHeader(length, options) {\n  options = options || {};\n  var RIFF = new Buffer('RIFF');\n  var WAVE = new Buffer('WAVE');\n  var fmt = new Buffer('fmt ');\n  var data = new Buffer('data');\n  var MAX_WAV = 4294967295 - 100;\n  var endianness = 'LE';\n  var format = 1; // raw PCM\n\n  var channels = options.channels || 1;\n  var sampleRate = options.sampleRate || 44100;\n  var bitDepth = options.bitDepth || 16;\n  var headerLength = 44;\n  var dataLength = length || MAX_WAV;\n  var fileSize = dataLength + headerLength;\n  var header = new Buffer(headerLength);\n  var offset = 0; // write the \"RIFF\" identifier\n\n  RIFF.copy(header, offset);\n  offset += RIFF.length; // write the file size minus the identifier and this 32-bit int\n\n  debug(\"Writing filesize: %d\", fileSize);\n  header['writeUInt32' + endianness](fileSize - 8, offset);\n  offset += 4; // write the \"WAVE\" identifier\n\n  WAVE.copy(header, offset);\n  offset += WAVE.length; // write the \"fmt \" sub-chunk identifier\n\n  fmt.copy(header, offset);\n  offset += fmt.length; // write the size of the \"fmt \" chunk\n  // XXX: value of 16 is hard-coded for raw PCM format. other formats have\n  // different size.\n\n  header['writeUInt32' + endianness](16, offset);\n  offset += 4; // write the audio format code\n\n  header['writeUInt16' + endianness](format, offset);\n  offset += 2; // write the number of channels\n\n  header['writeUInt16' + endianness](channels, offset);\n  offset += 2; // write the sample rate\n\n  header['writeUInt32' + endianness](sampleRate, offset);\n  offset += 4; // write the byte rate\n\n  var byteRate = sampleRate * channels * bitDepth / 8;\n  header['writeUInt32' + endianness](byteRate, offset);\n  offset += 4; // write the block align\n\n  var blockAlign = channels * bitDepth / 8;\n  header['writeUInt16' + endianness](blockAlign, offset);\n  offset += 2; // write the bits per sample\n\n  header['writeUInt16' + endianness](bitDepth, offset);\n  offset += 2; // write the \"data\" sub-chunk ID\n\n  data.copy(header, offset);\n  offset += data.length; // write the remaining length of the rest of the data\n\n  header['writeUInt32' + endianness](dataLength, offset);\n  offset += 4; // flush the header and after that pass-through \"dataLength\" bytes\n\n  return header;\n};","map":null,"metadata":{},"sourceType":"script"}